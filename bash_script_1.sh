#!/bin/bash

#--------------------------------------------------------------------
# глобальные переменные для разукрашивания вывода echo
#--------------------------------------------------------------------

RED='\033[0;31m' # красный текст

YELLOW='\033[0;33m' # желтый текст

GREEN='\033[0;32m' # зеленый текст

MAGENTA='\033[0;35m' # фиолетовый текст

NORMAL='\033[0m' # атрибуты по умолчанию

#--------------------------------------------------------------------
# объявление основных глобальных переменных 
#--------------------------------------------------------------------

ok=0 # переменная-флаг для обработки ввода 

dir_path="" # переменная для хранения пути к каталогу

ch=0 # переменная для обработки выбора 

#--------------------------------------------------------------------
# обработка позиционных параметров 
#--------------------------------------------------------------------

if ! [[ -z "$1" ]]; then
	dir_path=$1
else
	dir_path="labfiles"
fi

#--------------------------------------------------------------------
# проверка соержимого файла для пукнтов 1 и 2 
#--------------------------------------------------------------------

check_database()
{
        # сбрасываем флаг
        db_ok=0

        # если такой файл существует
        if [[ ! -z $file_path ]]; then

        # считаем количество строк совпадающих с шаблоном
        # и сравниваем их с итоговым количеством строк
        str_count_all=$(wc -l $file_path | awk '{print $1}') # wc так же выводила адрес файла, с помощью awk это было убрано
        first_str_count=$(cut -d' ' -f1 $file_path | grep -cE "^[A-Za-z]+$" )
        second_str_count=$(cut -d' ' -f2 $file_path | grep -cE "^[01]+$" )

# контроль содержимого переменных 
#        echo "STR_COUNT: $str_count_all" # контроль
#        echo "FIRST_STR_COUNT: $first_str_count" # контроль
#        echo "SECOND_STR_COUNT: $second_str_count" # контроль

        # само сравнение
        if [[ $str_count_all == $first_str_count ]] && [[ $str_count_all == $second_str_count  ]]; then # если все ОК
                db_ok=1 # поднимаем флаг
        else
                echo -e "\n${RED}ОШИБКА: файл с посещаемостью группы $group_num поврежден!${NORMAL}\n"
        fi
fi

}

#--------------------------------------------------------------------
# выводит упорядоченный по посещаемости список группы
#--------------------------------------------------------------------

# ввод группы
echo -e "${GREEN}Введите интересующую Вас группу (на латинице):${NORMAL} "

# ввод и проверка в цикле введенной группы
while [[ $ok -eq 0 ]]; do # пока флаг проверки 0

        read -p "-> " group_num # читаем (вводим) номер группы 

        if [[ "$group_num" =~ A-[0][0-9]-[0-9][0-9]$ ]]; then # сравниваем с шаблоном
             # если все ОК
                ok=1 # делаем 1 для выхода из цикла проверки
        else # ошибка при вводе 
        echo -e "\n${RED}ОШИБКА: группа введена неверно! Попробуйте еще раз!${NORMAL}\n"
        echo -e "\n${YELLOW}ПОДСКАЗКА: группа должна иметь следующий формат: A-[0][0-9]-[0-9][0-9]${NORMAL}\n"
        fi
done

# выбор из двух предметов
echo -e  "${GREEN}Введите 1 для выбора предмета \"Криптозоология\" и 2 для \"Пивоварение\":${NORMAL}"

ok=0 # обнуление ошибки
ch=0 # обнуление выбора

# проверка выбора предмета
while [[ $ok -eq 0 ]]; do # пока флаг проверки 0

        read -p "-> " ch # читаем (вводим) ключ выбора варианта

        if [[ $ch == 1 ]]; then # если выбрали первый вариант
             # все ОТЛИЧНО
                sub_name="Криптозоология"
                ok=1
        elif [[ $ch == 2 ]]; then # если выбрали второй вариант
                sub_name="Пивоварение"
                ok=1
        else # такие дела
                echo -e "\n${RED}ОШИБКА: ключ введен неверно!  Выберите 1 или 2!${NORMAL}\n"
        fi

done

# поиск файла с посещаемостью 
file_path=$(find $dir_path/$sub_name -name "$group_num-attendance") # результат записываем в переменную

# вызов функции проверки содержимого файла с посещаемостью
check_database

# проверка, найден ли файл с посещаемостью
if [[ ! -z $file_path ]] && [[ -s $file_path ]] && [[ $db_ok == 1 ]]; then

        echo -e "${GREEN}Введите 1 для выбора сортировки по возрастанию и 2 по убыванию:${NORMAL}"

        ok=0 # обнуление ошибки
        ch=0 # обнуление выбора

        # ввод и проверка варианта сортировки
        while [[ $ok -eq 0 ]]; do # пока флаг проверки 0

                read -p "-> " ch # читаем (вводим) ключ выбора варианта

                if [[ $ch == 1 || $ch == 2 ]]; then # сравниваем с 1 или 2
                     # все ОТЛИЧНО
                        ok=1
                else # такие дела
                        echo -e "\n${RED}ОШИБКА: ключ введен неверно!  Выберите 1 или 2!${NORMAL}\n"
                fi

        done

        # вывод сообщения на экран 
        echo ""
        echo "------------------------------------------------------------------------"
        echo "                     Список группы $group_num                           "
        echo "------------------------------------------------------------------------"
        echo "Пользователь БАРС |       Посещения        |  Общее количество посещений"
        echo "------------------------------------------------------------------------"
# пояснение: копируем поле $2 в поле $3 -> убираем все нули из посещаемости с помощью
# встроенной в awk функции gsub -> вычисляем количество единиц через длину строки
# c помощью встроенной в awk функции lenght () -> записываем результат в третье поле->
# -> выводим на экран 

if [[ $ch == 1 ]]; then # снова сравниваем это что-то с ЧИСЛОМ
             # сортировка по возрастанию
                awk '{$3=$2; gsub(/0/, "", $3); len=length($3); gsub(/1*/, len, $3); print $1 "   " $2  "   " $3}' $file_path | sort -k3n -k1 |  column -t -o "    |  "
# поэтапное преобразование исходного списка и сортировка

        else # сортировка по убыванию
                awk '{$3=$2; gsub(/0/, "", $3); len=length($3); gsub(/1*/, len, $3); print $1 "   " $2  "   " $3}' $file_path | sort -k3nr -k1 | column -t -o "    |  "
# сортировка с ключом -r ~ reverse

        fi

# если файл с данными пуст
elif [[ ! -z $file_path ]] && [[ ! -s $file_path ]]; then
        echo -e "\n${RED}ОШИБКА: файл с посещаемостью группы $group_num пуст!${NORMAL}\n"

# если файл не существует
elif [[ -z $file_path ]]; then
        echo -e "\n${RED}ОШИБКА: файл с посещаемостью группы $group_num не найден!${NORMAL}\n"

fi

echo ""

