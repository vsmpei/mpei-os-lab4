#!/bin/bash

#--------------------------------------------------------------------
# глобальные переменные для разукрашивания вывода echo
#--------------------------------------------------------------------

RED='\033[0;31m' # красный текст

YELLOW='\033[0;33m' # желтый текст

GREEN='\033[0;32m' # зеленый текст

MAGENTA='\033[0;35m' # фиолетовый текст

NORMAL='\033[0m' # атрибуты по умолчанию

#--------------------------------------------------------------------
# объявление основных глобальных переменных 
#--------------------------------------------------------------------

ok=0 # переменная-флаг для обработки ввода 

dir_path="" # переменная для хранения пути к каталогу

ch=0 # переменная для обработки выбора 

#--------------------------------------------------------------------
# обработка позиционных параметров 
#--------------------------------------------------------------------

if ! [[ -z "$1" ]]; then
        dir_path=$1
else
        dir_path="labfiles"
fi

#--------------------------------------------------------------------
# проверка соержимого файла для пукнтов 1 и 2 
#--------------------------------------------------------------------

check_database()
{
        # сбрасываем флаг
        db_ok=0

        # если такой файл существует
        if [[ ! -z $file_path ]]; then

        # считаем количество строк совпадающих с шаблоном
        # и сравниваем их с итоговым количеством строк
        str_count_all=$(wc -l $file_path | awk '{print $1}') # wc так же выводила адрес файла, с помощью awk это было убрано
        first_str_count=$(cut -d' ' -f1 $file_path | grep -cE "^[A-Za-z]+$" )
        second_str_count=$(cut -d' ' -f2 $file_path | grep -cE "^[01]+$" )

# контроль содержимого переменных 
#        echo "STR_COUNT: $str_count_all" # контроль
#        echo "FIRST_STR_COUNT: $first_str_count" # контроль
#        echo "SECOND_STR_COUNT: $second_str_count" # контроль

        # само сравнение
        if [[ $str_count_all == $first_str_count ]] && [[ $str_count_all == $second_str_count  ]]; then # если все ОК
                db_ok=1 # поднимаем флаг
        else
                echo -e "\n${RED}ОШИБКА: файл с посещаемостью группы $group_num поврежден!${NORMAL}\n"
        fi
fi

}

#--------------------------------------------------------------------
# выводит студента с лучшей посещаемостью в конкретной 
# группе, а так же количество посещенных им занятий 
#-------------------------------------------------------------------

# ввод группы
echo -e "${GREEN}В какой группе учится интересующий Вас студент (на латинице):${NORMAL}"

# ввод и проверка в цикле введенной группы
while [[ $ok -eq 0 ]]; do # пока флаг проверки 0

        read -p "-> " group_num # читаем номер группы

        if [[ "$group_num" =~ A-[0][0-9]-[0-9][0-9]$ ]]; then  # с шаблоном
             # если все ОК
                ok=1 # делаем 1 для выхода из цикла проверки
        else # ошибка при ввоже
                echo -e "\n${RED}ОШИБКА: группа введена неверно! Попробуйте еще раз!${NORMAL}"
                echo -e "\n${YELLOW}ПОДСКАЗКА: группа должна иметь следующий формат: A-[0][0-9]-[0-9][0-9]${NORMAL}\n"
        fi
done

# выбор предмета
echo -e "${GREEN}Введите 1 для выбора предмета \"Криптозоология\" и 2 для \"Пивоварение\":${NORMAL}"

# обнуление переменных
ok=0 # обнуление переменной проверки ввода
ch=0 # обнуление переменной выбора

# проверка выбора предмета
while [[ $ok -eq 0 ]]; do # пока флаг проверки 0

        read -p "-> " ch # снова вводим

        if [[ $ch == 1 ]]; then # если выбрали первый варик
                # все ОТЛИЧНО
                sub_name="Криптозоология"
                ok=1
        elif [[ $ch == 2 ]]; then
                sub_name="Пивоварение"
                ok=1
        else # такие дела
                echo -e "\n${RED}ОШИБКА: ключ введен неверно! Выберите 1 или 2!${NORMAL}\n"
        fi

done

# поиск файла с посещаемостью 
file_path=$(find $dir_path/$sub_name -name "$group_num-attendance") # результат записываем в переменную

# вызов функции проверки содержимого файла с посещаемостью
check_database

# проверка, найден ли файл с посещаемостью, и если найден, то пуст ли он
if [[ ! -z $file_path ]] && [[ -s $file_path ]] && [[ $db_ok == 1 ]]; then
# вывод студента с лучшей посещаемостью
        echo ""
        echo "Лучший(ие) студент(ы) по посещаемости в группе $group_num: "
        echo ""

# пояснение: убираем все нули из посещаемости с помощью функции gsub, встроенной в awk
# -> считаем количество единиц через функцию lenght, которая встроена в awk -> заменяем
# все 0 на посещаемость -> выводим на экран

# ищем максимальное значение посещений
#max_value=$(awk '{$3=$2; gsub(/0/, "", $3); len=length($3); gsub(/1*/, len, $3);  print "Никнейм в БАРС: " $1 " Количество посещенных занятий: " $3}' $file_path | sort -t " " -n -k8 | tail -n 1 | awk '{print $8}')

max_value=$(awk '{$3=$2; gsub(/0/, "", $3); len=length($3); gsub(/1*/, len, $3);  print $1 " " $3}' $file_path | sort -t " " -n -k2 | tail -n 1 | awk '{print $2}')

#echo $max_value # контроль максимального значения

# выводим строки с максимальным значением max_value в колонке с посещаемостью
awk -v max_value="${max_value}" '{$3=$2; gsub(/0/, "", $3); len=length($3); gsub(/1*/, len, $3)} $3==max_value {print "Никнейм в БАРС: " $1 " Количество посещенных занятий: " $3}' $file_path | sort -k4 | column -t -o "  "

# если файл с данными пуст
elif [[ ! -z $file_path ]] && [[ ! -s $file_path ]]; then
        echo -e "\n${RED}ОШИБКА: файл с посещаемостью группы $group_num пуст!${NORMAL}\n"

# иначе
# если файл не существует
elif [[ -z $file_path ]]; then
        echo -e "\n${RED}ОШИБКА: файл с посещаемостью группы $group_num не найден!${NORMAL}\n"
fi

echo ""

