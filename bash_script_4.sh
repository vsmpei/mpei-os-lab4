#!/bin/bash

#--------------------------------------------------------------------
# глобальные переменные для разукрашивания вывода echo
#--------------------------------------------------------------------

RED='\033[0;31m' # красный текст

YELLOW='\033[0;33m' # желтый текст

GREEN='\033[0;32m' # зеленый текст

MAGENTA='\033[0;35m' # фиолетовый текст

NORMAL='\033[0m' # атрибуты по умолчанию

#--------------------------------------------------------------------
# объявление основных глобальных переменных 
#--------------------------------------------------------------------

ok=0 # переменная-флаг для обработки ввода 

dir_path="" # переменная для хранения пути к каталогу

ch=0 # переменная для обработки выбора 

#--------------------------------------------------------------------
# обработка позиционных параметров
#--------------------------------------------------------------------

if ! [[ -z "$1" ]]; then
        dir_path=$1
else
        dir_path="labfiles"
fi

#--------------------------------------------------------------------
# проверка соержимого файла для пункта четыре
#--------------------------------------------------------------------

check_database_test()
{
         # сбрасываем флаг
        db_ok=0

        # если такой файл существует
        if [[ ! -z $file_path ]]; then

        # считаем количество строк совпадающих с шаблоном
        # и сравниваем их с итоговым количеством строк
        str_count_all=$(wc -l $file_path | awk '{print $1}') # wc так же выводила адрес файла, с помощью awk это было убрано
        first_str_count=$(cut -d';' -f1 $file_path | grep -cE "A-[0][0-9]-[0-9][0-9]$" )
        second_str_count=$(cut -d';' -f2 $file_path | grep -cE "^[A-Za-zА-Яа-я0-9]+$" )
        third_str_count=$(cut -d';' -f3 $file_path | grep -cE "^[0-9]+$" )
        fourth_str_count=$(cut -d';' -f4 $file_path | grep -cE "^[0-9]+$" )
        fifth_str_count=$(cut -d';' -f4 $file_path | grep -cE "^[0-9]+$" )
# контроль содержимого переменных 
#        echo "STR_COUNT: $str_count_all" # контроль
#        echo "FIRST_STR_COUNT: $first_str_count" # контроль
#        echo "SECOND_STR_COUNT: $second_str_count" # контроль
#        echo "THIRD_STR_COUNT: $third_str_count" # контроль
#        echo "FOURTH_STR_COUNT: $fourth_str_count" # контроль
#        echo "FIFTH_STR_COUNT: $fifth_str_count" # контроль
        # само сравнение
        if [[ $str_count_all == $first_str_count ]] && [[ $str_count_all == $third_str_count  ]] && [[ $str_count_all == $fourth_str_count  ]] && [[ $str_count_all == $fifth_str_count  ]]; then # если все ОК
                db_ok=1 # поднимаем флаг
        else
                echo -e "\n${RED}ОШИБКА: файл TEST-$test_num с тестами поврежден!${NORMAL}\n"
        fi
fi

}


#--------------------------------------------------------------------
# выводит лучших студентов по среднему баллу правильных ответов
# по тесту
#--------------------------------------------------------------------

# выбор из двух предметов 
echo -e "${GREEN}Введите 1 для выбора предмета \"Криптозоология\" и 2 для \"Пивоварение\":${NORMAL}"

# выбираем предмет с проверкой ввода
while [[ $ok -eq 0 ]]; do # пока флаг проверки 0

        read -p "-> " ch # читаем (вводим) выбор варианта 

        if [[ $ch == 1 ]]; then # если выбрали первый вариант
                sub_name="Криптозоология"
                ok=1
        elif [[ $ch == 2 ]]; then # если выбрали второй вариант
                sub_name="Пивоварение"
                ok=1
        else # ошибка при вводе
                echo -e "\n${RED}ОШИБКА: ключ введен неверно! Выберите 1 или 2!${NORMAL}\n"
        fi

done

ok=0 # обнуляем переменную проверки ошибки

# выбираем тест с проверкой ввода
echo -e "${GREEN}Введите номер теста (от 1 до 4):${NORMAL}"

while [[ $ok -eq 0 ]]; do # пока флаг проверки 0

        read -p "-> " test_num # вводим

        if ! [[ $test_num =~ ^[^0-9]+$ || $test_num -gt 4 || $test_num -le 0 ]]; then # проверка диапазона
                # все ОК
                ok=1 # выходим из цикла
        else # ошибка при вводе
                echo -e "\n${RED}ОШИБКА: неверный формат ввода!  Введите целое число в диапазоне от 1 до 4!${NORMAL}\n"
        fi

done

# поиск файла с тестом
file_path=$(find $dir_path/$sub_name -name "TEST-$test_num") # результат записываем в переменную

# контроль найденного файла
# echo "$file_path"

# вызов функции проверки содердимого файла с тестом
check_database_test

if [[ ! -z $file_path ]] && [[ -s $file_path  ]] && [[ $db_ok == 1 ]]; then

# считаем количество студентов в файле с тестом
stud_count=$(awk -F ";" '{count[$2]++} END {for (n in count) print n}' $file_path | wc -l) # число уникальных значений во втором столбце (фамилии) = количество студентов

ok=0 # обнуляем переменную проверки ошибки

# ввод количества отображаемых студентов
echo -e "${GREEN}Введите количество отображаемых студентов (до $stud_count):${NORMAL}"

while [[ $ok -eq 0 ]]; do # пока флаг проверки 0

        read -p "-> " line_count # вводим

        # обязательно проверяем, что ввели именно ЦЕЛОЕ ЧИСЛО, и что оно попадает в диапазон
        if ! [[ $line_count =~ ^[^0-9]+$ || $line_count -gt $stud_count || $line_count -le 0 ]]; then # проверка диапазона
             # все ОТЛИЧНО
                ok=1 # выходим из цикла
        else # ошибка при вводе
                echo -e "\n${RED}ОШИБКА: неверный формат ввода! Введите целое число в диапазоне от 1 до $stud_count!${NORMAL}\n"
        fi

done

# вывод топ студентов по среднему баллу
echo "--------------------------------------------------------------------------"
echo "           Топ студентов по среднему баллу (по попыткам)                  "
echo "--------------------------------------------------------------------------"
echo "Место |     Студент       |     Группа    |  Средний балл по попыткам"
echo "--------------------------------------------------------------------------"

# объяснение: по сути создается три массива group, sum и count перед обработкой файла
# в массив group записывается группа из поля $1 по уникальному значению во втором поле с фамилией
# в массив sum записывается сумма для каждого уникального значения из поля $2 с фамилией
# в массив count - считаем количество таких записей, чтобы потом на него поделить (среднее)
# затем в цикле просто выводим это все, потом сортируем, потом берем первые $line_count записей, такие дела
awk -F ";" '{group[$2]=$1; sum[$2]+=$4; count[$2]++; } END {for (i in sum) print "   ", i,";", group[i],";", sum[i]/count[i];}' $file_path | sort -t ";" -k3nr -k1 | awk -F ";" '{print NR "    "$1"   "$2"        "$3}' | head -n $line_count | column -t -o "    |   "
# если файл с данными пуст
elif [[ ! -z $file_path ]] && [[ ! -s $file_path ]]; then
        echo -e "\n${RED}ОШИБКА: файл TEST-$test_num с тестами пуст!${NORMAL}\n"

elif [[ -z $file_path ]]; then
        echo -e "\n${RED}ОШИБКА: файл TEST-$test_num с тестами не найден!${NORMAL}\n"
fi

echo ""

